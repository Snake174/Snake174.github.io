<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="content-language" content="ru">
    <meta name="format-detection" content="telephone=no" />
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width" />
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="shortcut icon" href="img/dog.ico" type="image/x-icon" />
    <meta name="robots" content="index, follow">
    <meta name="keywords" content="Love2D,танк,поворот,перемещение,следы,выстрел,lua,2d,game,tank,игра,анимация,hump,anim8,particle system,particles,частицы,система частиц">
    <meta name="description" content="Создание танка на Love2D, управление стрельбой, перемещением и поворотом.">
    <meta name="author" content="">
    <meta name="copyright" content="">
    
    <title>Sn@Ke - Создание танка на движке LÖVE</title>

    <link rel="stylesheet" type="text/css" href="css/jquery.dataTables.min.css">
    <link rel="stylesheet" type="text/css" href="css/QapTcha.jquery.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="css/twilight.css" />
    
    <script type="text/javascript">
      var today = new Date();
      var d = today.getDate();
      var m = today.getMonth() + 1;

      if (d == 31 && m == 10)
        document.write('<link rel="stylesheet" type="text/css" href="css/haloween.css" />');
      else if (d == 14 && m == 3)
        document.write('<link rel="stylesheet" type="text/css" href="css/max.css" />');
      else
        document.write('<link rel="stylesheet" type="text/css" href="css/style.css" />');
    </script>
    
    <style type="text/css" class="init"></style>

    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript" src="js/jquery-ui.js"></script>
    <script type="text/javascript" src="js/jquery.ui.touch.js"></script>
    <script type="text/javascript" src="js/QapTcha.jquery.js"></script>
    <script type="text/javascript" src="js/menu.js"></script>
    <script type="text/javascript" src="js/jquery.dataTables.min.js"></script>
    <script type="text/javascript" src="js/rainbow-custom.min.js"></script>
    <script type="text/javascript" src="js/custom.js"></script>
    <script type="text/javascript" language="javascript" class="init"></script>
  </head>

  <body>
    <!-- Google Tag Manager -->
    <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-M394D3"
      height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-M394D3');</script>
    <!-- End Google Tag Manager -->
    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-57173099-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script data-type="slim" data-position="bottom" data-timer="60" data-appkeyid="1f8c95b3-9dcd-46a1-a8fb-99498a4199ff" src="//s.appintop.com/widget/appbnr.js" async="1"></script>
    <table border="0" width="100%">
      <tr>
        <td style="height: 100px;">
          <a href="index.html"><img src="img/head.jpg"></a>
        </td>
        <td>
          <div class="header"></div>
        </td>
      </tr>
      <tr>
        <td valign="top" style="width: 300px;">
        
          <form action="http://www.google.ru" id="cse-search-box" target="_blank">
            <div>
              <input type="hidden" name="cx" value="partner-pub-4693591635005759:6207939625" />
              <input type="hidden" name="ie" value="UTF-8" />
              <input type="text" name="q" style="width: 295px;" />
              <input type="submit" name="sa" value="&#x041f;&#x043e;&#x0438;&#x0441;&#x043a;" />
            </div>
          </form>
          <script type="text/javascript" src="http://www.google.com/jsapi"></script>
          <script type="text/javascript">google.load("elements", "1", {packages: "transliteration"});</script>
          <script type="text/javascript" src="http://www.google.com/cse/t13n?form=cse-search-box&t13n_langs=en"></script>
          <script type="text/javascript" src="http://www.google.ru/coop/cse/brand?form=cse-search-box&amp;lang=ru"></script>

          
          <script type="text/javascript" src="http://www.google.com/cse/query_renderer.js"></script>
          <div id="queries"></div>
          <script src="http://www.google.com/cse/api/partner-pub-4693591635005759/cse/6207939625/queries/js?oe=UTF-8&amp;callback=(new+PopularQueryRenderer(document.getElementById(%22queries%22))).render"></script>
        
          <ul id="menu">
            <li>
              <a href="#">Программы</a>
              <ul>
                <li><a href="guitar_chords.html">Guitar Chords</a></li>
                <li><a href="love_exporter.html">LÖVE Exporter</a></li>
                <li><a href="pipmak_assistant.html">Pipmak Assistant</a></li>
                <li><a href="tasm_ide.html">TASM IDE</a></li>
              </ul>
            </li>
            <li>
              <a href="#">Статьи</a>
              <ul>
                <li><a href="tanks.html">Создание танка на движке LÖVE</a></li>
              </ul>
            </li>
            <li>
              <a href="#">Игры</a>
              <ul>
                <li><a href="vernike.html">Не следует обманывать инспектора</a></li>
              </ul>
            </li>
            <li>
              <a href="#">Обратная связь</a>
              <ul>
                <li><a href="contacts.html">Контакты</a></li>
                <li><a href="payments.html">Поддержать разработчиков</a></li>
              </ul>
            </li>
          </ul>
        </td>
        <td valign="top" rowspan="2" style="padding: 5px;">

<center><h1>Создание танка на движке LÖVE</h1></center>

<p>
Всем доброго времени суток. В данной статье (если это можно назвать статьёй, в основном <b>код</b>), как вы уже наверно догадались, пойдёт речь о создании танка на игровом движке <a href="http://love2d.org/" target="_blank"><b>LÖVE</b></a>.
</p>

<p>
Прежде всего определим, что должен делать наш создаваемый <b>танк</b>:
<ul>
  <li>первое и самое главное на мой взгляд - это <b>перемещение</b>, которое соответствует "нормальному" танку. Т.е. при нажатии на клавиши <b>W</b> и <b>S</b> танк будет двигаться вперёд и назад, а при нажатии на клавиши <b>A</b> и <b>D</b> танк будет поворачиваться влево и вправо соответственно.</li>
  <li>второе немаловажное действие - <b>стрельба</b>. Левой кнопкой мыши будет осуществляться стрельба обычными патронами, а на правую кнопку мыши мы "повесим" стрельбу ракетами.</li>
  <li>при движении у танка должны двигаться гусеницы.</li>
  <li>у танка будут выходить выхлопные газы.</li>
  <li>ну и последнее - танк должен оставлять за собой следы, которые через определённый промежуток времени будут исчезать.</li>
</ul>
</p>

<p>
Для начала нам нужно создать все изображения и поместить их в какую-нибудь папку, например <b>data/images</b>.
</p>

<p>
Художник из меня плохой, поэтому всю графику мне предоставил пользователь форума <a href="http://gcup.ru/" target="_blank"><b>GcUp</b></a> <a href="http://gcup.ru/index/8-47390" target="_blank">silver52rus</a>, за что ему <b>ОГРОМНОЕ СПАСИБО</b>.
</p>

<p>
<center><b>Корпус танка с анимацией гусениц:</b></center>
<center><img src="img/tanks/tank_body.png" width="576" height="64"></center>
</p>

<p>
<center><b>Башня танка:</b></center>
<center><img src="img/tanks/tank_top.png"></center>
</p>

<p>
<center><b>След, оставляемый танком при движении:</b></center>
<center><img src="img/tanks/tank_trail.png"></center>
</p>

<p>
<center><b>Выхлопные газы:</b></center>
<center><img src="img/tanks/cloud.png"></center>
</p>

<p>
<center><b>Патрон:</b></center>
<center><img src="img/tanks/tank_bullet.png"></center>
</p>

<p>
<center><b>Ракета:</b></center>
<center><img src="img/tanks/rocket.png"></center>
</p>

<p>
<center><b>Частицы для ракеты:</b></center>
<center><img src="img/tanks/rocket_smoke.png" width="16" height="16"></center>
</p>

<p>
Далее нам нужны вспомогательные библиотеки: 
<ul>
  <li><a href="http://www.love2d.org/wiki/HUMP" target="_blank"><b>HUMP</b></a> для работы с <b>классами</b>, <b>векторами</b> и <b>таймером</b>.</li>
  <li><a href="http://www.love2d.org/wiki/anim8"><b>anim8</b></a> для работы с <b>анимацией</b>.</li>
  <li>модуль <a href="files/tanks/Input.lua" download="Input.lua"><b>Input</b></a>, который я написал для более удобного контроля над <b>вводом</b> (по крайней мере для меня). Это не финальная его версия, планируется ещё добавить поддержку <b>Android</b>.</li>
</ul>

Нужно их скачать и поместить в папку <b>classes</b>.
</p>

<p>
В итоге должна получиться такая структура проекта:
<center><img src="img/tanks/project_structure.png"></center>
</p>

<p>
Для начала разберёмся с файлом <b>main.lua</b>:
</p>

<p>
<pre>
<code data-language="lua">
-- Подключаем необходимые библиотеки
Class = require "classes.hump.class"
Vector = require "classes.hump.vector"
Timer = require "classes.hump.timer"
Input = require "classes.Input"
Anim = require "classes.anim8.anim8"

function love.load()
  -- Здесь будет создаваться экземпляр класса "Танк"
end

function love.run()
  if love.math then
    love.math.setRandomSeed( os.time() )
  end

  if love.event then
    love.event.pump()
  end

  if love.load then
    love.load( arg )
  end

  if not (love.window and love.graphics and love.window.isCreated() and love.timer) then
    return
  end

  love.timer.step()
  love.graphics.setBackgroundColor( 50, 50, 50 )  -- Цвет фона

  -- Главный цикл приложения
  while Input.running() do
    love.timer.step()
    local dt = love.timer.getDelta()

    Input.update()
    
    -- Здесь будет функция обновления танка

    love.graphics.clear()
    love.graphics.origin()
    
    -- Здесь будет функция отрисовки танка

    love.graphics.present()

    Input.reset()

    love.timer.sleep( 0.001 )
  end
end
</code>
</pre>
</p>

<p>
В самом начале файла подключаются все необходимые для работы <b>модули</b>, которые будут доступны из других <b>классов</b>. В <b>главном цикле</b> происходит проверка ввода и выполняются функции обновления и отрисовки <b>танка</b>.
</p>

<p>
Ниже приведён код файла настроек приложения <b>conf.lua</b>. Здесь можно указать заголовок, ширину и высоту окна, включить или отключить какие-то модули, сделать окно на весь экран ну и прописать какие-нибудь <b>дополнительные настройки</b>. Более подробно о настройках проекта можно ознакомиться <a href="http://love2d.org/wiki/Config_Files" target="_blank">здесь</a>.
</p>

<p>
<pre>
<code data-language="lua">
function love.conf(c)
  c.version = "0.9.1"
  c.title = "Tanks"
  c.window.width = 1024
  c.window.height = 768
  c.window.resizable = false
  c.window.fullscreen = false
  c.window.fullscreentype = "normal"
  c.window.vsync = true
  c.window.fsaa = 4
  c.modules.audio = true
  c.modules.event = true
  c.modules.graphics = true
  c.modules.image = true
  c.modules.joystick = false
  c.modules.keyboard = true
  c.modules.math = true
  c.modules.mouse = true
  c.modules.physics = false
  c.modules.sound = true
  c.modules.system = true
  c.modules.timer = true
  c.modules.window = true
end
</code>
</pre>
</p>

<p>
Наконец-то дошли до самого интересного момента - создание класса <b>"Танк"</b>.
</p>

<p>
<pre>
<code data-language="lua">
local Tank = Class {
  -- конструктор класса
  init = function( self, pos )
    -- позиция танка
    self.pos = pos
    
    -- направление корпуса танка
    self.body_dir = Vector( 0, 0 )
    
    -- направление башни танка
    self.top_dir = Vector( 0, -1 )
    
    -- изображения корпуса и башни танка
    self.body = love.graphics.newImage("data/images/tank_body.png")
    self.top = love.graphics.newImage("data/images/tank_top.png")
	
    -- размер одного кадра корпуса танка
    self.size = Vector( 128, 128 )
	
    -- сетка анимаций корпуса танка
    -- в функцию передаётся размер одного кадра анимации и размер изображения с анимациями
    local grid = Anim.newGrid( self.size.x, self.size.y, self.body:getWidth(), self.body:getHeight() )

    -- анимация "покоя" танка (по сути первый кадр)
    self.iddle = Anim.newAnimation( grid( 1, 1 ), 1 )

    -- анимация движения танка
    -- "1-9" - с 1-го по 9-й кадр
    -- 1 - номер строки с кадрами анимации (в данном примере одна строка, в которой 9 кадров)
    -- 0.05 - время смены кадров анимации
    self.run = Anim.newAnimation( grid( "1-9", 1 ), 0.05 )

    -- текущая анимация - "покой"
    self.animation = self.iddle

    -- изображение следа, оставляемого танком
    self.trail_image = love.graphics.newImage("data/images/tank_trail.png")

    -- шаг следов (чтобы следы шли не сплошной полосой, а через определённый промежуток)
    self.trail_step = 0

    -- массив со следами
    self.tank_trails = {}

    -- угол поворота корпуса танка
    self.body_angle = 0

    -- угол поворота башни танка
    self.top_angle = 0

    -- скорость перемещения танка
    self.max_speed = 70

    -- скорость поворота башни танка
    self.max_rot_speed = 100

    -- скорость полёта пуль
    self.bullet_speed = 350
    
    -- скорость полёта ракет
    self.rocket_speed = 250

    -- массивы с пулями и ракетами
    self.bullets = {}
    self.rockets = {}

    -- дым от танка
    self.tank_smoke = love.graphics.newImage("data/images/cloud.png")
    self.ps = love.graphics.newParticleSystem( self.tank_smoke, 32 )
    self.ps:setAreaSpread( "uniform", 0, 0 )
    self.ps:setDirection( math.rad( self.body_angle + 90 ) )
    self.ps:setEmissionRate( 10 )
    self.ps:setEmitterLifetime( -1 )
    self.ps:setInsertMode("bottom")
    self.ps:setLinearAcceleration( 0, 1, 0, 2 )
    self.ps:setParticleLifetime( 0.5, 1 )
    self.ps:setRadialAcceleration( 0, 5 )
    self.ps:setRotation( math.rad(0), math.rad( 360 ) )
    self.ps:setSpeed( 30, 50 )
    self.ps:setSpread( math.rad( 60 ) )
    self.ps:setPosition( self.pos.x, self.pos.y + 60 )
    self.ps:start()
  end,

  -- функция обновления
  update = function( self, dt )
    -- делаем текущую анимацию - анимация "покоя"
    self.animation = self.iddle
    
    -- плавный поворот башни танка за курсором
    local mousePos = Input.mousePos()
    local dir = self.pos - mousePos
	
    local targetAngle = -math.atan2( dir.x, dir.y ) / (math.pi / 180)
    local curAngle = self.top_angle
	
    if curAngle < 0 then
      curAngle = curAngle + 360
    end

    if targetAngle < 0 then
      targetAngle = targetAngle + 360
    end

    local a = curAngle - targetAngle

    if a > 180 then
      a = a - 360
    elseif a < -180 then
      a = a + 360
    end

    local s = dt * self.max_rot_speed

    if a >= -s - 0.5 and a <= s + 0.5 then
      self.top_angle = targetAngle
    elseif a > s + 0.5 then
      self.top_angle = self.top_angle - s
    elseif a < -s - 0.5 then
      self.top_angle = self.top_angle + s
    end
    
    -- направление башни танка
    self.top_dir.x = math.sin( math.rad( self.top_angle ) )
    self.top_dir.y = -math.cos( math.rad( self.top_angle ) )

    -- поворот корпуса танка по часовой стрелке
    if Input.keyHeld("d") then
      -- делаем текущей анимацию движения
      self.animation = self.run
      self.body_angle = self.body_angle + self.max_speed * dt

      if self.body_angle >= 360 then
        self.body_angle = 0
      end

      -- функция "оставления" следов
      self:makeTrail()
    end
	
    -- поворот корпуса танка против часовой стрелки
    if Input.keyHeld("a") then
      self.animation = self.run
      self.body_angle = self.body_angle - self.max_speed * dt

      if self.body_angle <= 0 then
        self.body_angle = 360
      end

      self:makeTrail()
    end
    
    -- движение вперёд
    if Input.keyHeld("w") then
      self.animation = self.run
      self.body_dir.x = math.sin( math.rad( self.body_angle ) )
      self.body_dir.y = -math.cos( math.rad( self.body_angle ) )
      self.pos = self.pos + self.body_dir:normalized() * self.max_speed * dt

      self:makeTrail()
    end
    
    -- движение назад
    if Input.keyHeld("s") then
      self.animation = self.run
      self.body_dir.x = math.sin( math.rad( self.body_angle ) )
      self.body_dir.y = -math.cos( math.rad( self.body_angle ) )
      self.pos = self.pos - self.body_dir:normalized() * self.max_speed * dt

      self:makeTrail()
    end
    
    -- стрельба пулями
    if Input.mouseDown("l") then
      local ind = #self.bullets + 1
      self.bullets[ ind ] = {}

      local x = self.pos.x - ((self.pos.y - 85) - self.pos.y) * math.sin( math.rad( self.top_angle ) )
      local y = self.pos.y + ((self.pos.y - 85) - self.pos.y) * math.cos( math.rad( self.top_angle ) )

      self.bullets[ ind ].pos = Vector( x, y )
      self.bullets[ ind ].dir = Vector( self.top_dir.x, self.top_dir.y ):normalized()
      self.bullets[ ind ].img = love.graphics.newImage("data/images/tank_bullet.png")
      self.bullets[ ind ].size = Vector( self.bullets[ ind ].img:getWidth(), self.bullets[ ind ].img:getHeight() )
      self.bullets[ ind ].angle = self.top_angle
    end

    -- стрельба ракетами
    if Input.mouseDown("r") then
      local ind = #self.rockets + 1
      self.rockets[ ind ] = {}

      local x = self.pos.x - ((self.pos.y - 85) - self.pos.y) * math.sin( math.rad( self.top_angle ) )
      local y = self.pos.y + ((self.pos.y - 85) - self.pos.y) * math.cos( math.rad( self.top_angle ) )

      self.rockets[ ind ].pos = Vector( x, y )
      self.rockets[ ind ].dir = Vector( self.top_dir.x, self.top_dir.y ):normalized()
      self.rockets[ ind ].img = love.graphics.newImage("data/images/rocket.png")
      self.rockets[ ind ].size = Vector( self.rockets[ ind ].img:getWidth(), self.rockets[ ind ].img:getHeight() )
      self.rockets[ ind ].angle = self.top_angle
      self.rockets[ ind ].smoke = love.graphics.newImage("data/images/rocket_smoke.png")
      self.rockets[ ind ].ps = love.graphics.newParticleSystem( self.rockets[ ind ].smoke, 256 )
      self.rockets[ ind ].ps:setAreaSpread( "uniform", 0, 0 )
      self.rockets[ ind ].ps:setDirection( math.rad( self.rockets[ ind ].angle + 90 ) )
      self.rockets[ ind ].ps:setEmissionRate( 512 )
      self.rockets[ ind ].ps:setEmitterLifetime( -1 )
      self.rockets[ ind ].ps:setInsertMode("bottom")
      self.rockets[ ind ].ps:setLinearAcceleration( 0, 10, 0, 30 )
      self.rockets[ ind ].ps:setParticleLifetime( 0.1, 0.5 )
      self.rockets[ ind ].ps:setRadialAcceleration( 0, 0 )
      self.rockets[ ind ].ps:setSpeed( 30, 50 )
      self.rockets[ ind ].ps:setSpread( math.rad( 30 ) )
      self.rockets[ ind ].ps:setPosition( 
        self.rockets[ ind ].pos.x
        - ((self.rockets[ ind ].pos.y + 16)
        - self.rockets[ ind ].pos.y)
        * math.sin( math.rad( self.rockets[ ind ].angle ) ),
        self.rockets[ ind ].pos.y
        + ((self.rockets[ ind ].pos.y + 16)
        - self.rockets[ ind ].pos.y)
        * math.cos( math.rad( self.rockets[ ind ].angle ) ) )
      self.rockets[ ind ].ps:start()
    end

    -- обновление пуль и ракет
    for i = #self.bullets, 1, -1 do
      self.bullets[i].pos = self.bullets[i].pos + self.bullets[i].dir * self.bullet_speed * dt

      if self:checkBulletBounds( self.bullets[i] ) then
        table.remove( self.bullets, i )
      end
    end

    for i = #self.rockets, 1, -1 do
      self.rockets[i].pos = self.rockets[i].pos + self.rockets[i].dir * self.rocket_speed * dt
      self.rockets[i].ps:setPosition( 
        self.rockets[i].pos.x 
        - ((self.rockets[i].pos.y + 16)
        - self.rockets[i].pos.y)
        * math.sin( math.rad( self.rockets[i].angle ) ),
        self.rockets[i].pos.y
        + ((self.rockets[i].pos.y + 16)
        - self.rockets[i].pos.y)
        * math.cos( math.rad( self.rockets[i].angle ) ) )
      self.rockets[i].ps:update( dt )

      if self:checkRocketBounds( self.rockets[i] ) then
        table.remove( self.rockets, i )
      end
    end

    -- обновление анимации
    self.animation:update( dt )

    -- обновление дыма от танка
    self.ps:setPosition( self.pos.x - ((self.pos.y + 60) - self.pos.y) * math.sin( math.rad( self.body_angle ) ),
                         self.pos.y + ((self.pos.y + 60) - self.pos.y) * math.cos( math.rad( self.body_angle ) ) )
    self.ps:setDirection( math.rad( self.body_angle + 90 ) )
    self.ps:update( dt )

    -- выход по нажатию Escape
    if Input.keyDown("escape") then
      Input.exit()
    end
  end,
  
  -- функция отрисовки танка
  draw = function( self )
    -- сначала рисуем следы от танка
    for i = 1, #self.tank_trails do
      love.graphics.draw( self.tank_trails[i].img,
                          self.tank_trails[i].pos.x,
                          self.tank_trails[i].pos.y,
                          math.rad( self.tank_trails[i].angle ),
                          1,
                          1,
                          self.tank_trails[i].size.x / 2,
                          self.tank_trails[i].size.y / 2 )
    end

    -- отрисовка корпуса танка
    self.animation:draw( self.body,
                         self.pos.x,
                         self.pos.y,
                         math.rad( self.body_angle ),
                         1,
                         1,
                         self.size.x / 2,
                         self.size.y / 2 )

    -- отрисовка дыма от танка
    love.graphics.draw( self.ps, 0, 0 )

    -- отрисовка башни танка
    love.graphics.draw( self.top,
                        self.pos.x,
                        self.pos.y,
                        math.rad( self.top_angle ),
                        1,
                        1,
                        self.size.x / 2,
                        self.size.y / 2 + 27 )

    -- отрисовка пуль
    for i = 1, #self.bullets do
      love.graphics.draw( self.bullets[i].img,
                          self.bullets[i].pos.x,
                          self.bullets[i].pos.y,
                          math.rad( self.bullets[i].angle ),
                          1,
                          1,
                          self.bullets[i].size.x / 2,
                          self.bullets[i].size.y / 2 )
    end

    -- отрисока ракет
    for i = 1, #self.rockets do
      love.graphics.draw( self.rockets[i].img,
                          self.rockets[i].pos.x,
                          self.rockets[i].pos.y,
                          math.rad( self.rockets[i].angle ),
                          1,
                          1,
                          self.rockets[i].size.x / 2,
                          self.rockets[i].size.y / 2 )

      love.graphics.draw( self.rockets[i].ps, 0, 0 )
    end
  end,
  
  -- функции, которые проверяют вылет пуль и ракет за пределы экрана
  checkBulletBounds = function( self, bul )
    if bul.pos.x <= 0 or bul.pos.x >= love.graphics.getWidth()
      or bul.pos.y <= 0 or bul.pos.y >= love.graphics.getHeight() then
      return true
    end

    return false
  end,

  checkRocketBounds = function( self, r )
    if r.pos.x <= 0 or r.pos.x >= love.graphics.getWidth()
      or r.pos.y <= 0 or r.pos.y >= love.graphics.getHeight() then
      return true
    end

    return false
  end,
  
  -- функция создания и удаления следов
  makeTrail = function( self )
    self.trail_step = self.trail_step + love.timer.getDelta()

    if self.trail_step >= 0.1 then
      self.trail_step = 0

      local ind = #self.tank_trails + 1
      self.tank_trails[ ind ] = {}
      self.tank_trails[ ind ].pos = Vector( self.pos.x, self.pos.y )
      self.tank_trails[ ind ].img = self.trail_image
      self.tank_trails[ ind ].angle = self.body_angle
      self.tank_trails[ ind ].size = Vector( self.trail_image:getWidth(), self.trail_image:getHeight() )

      -- удалить через 1 секунду первый созданный след
      Timer.add( 1, function() table.remove( self.tank_trails, 1 ) end )
    end
  end
}

return Tank
</code>
</pre>
</p>

<div>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- AdSenseAdaptiveBanner -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-4693591635005759"
     data-ad-slot="3074833226"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<p>
Попробую понятней объяснить, что в данном классе происходит. В основном нам интересна только функция обновления, поэтому рассмотрим её более подробней.
</p>

<p>
Первой строкой мы "сообщаем" танку, что должна проигрываться <b>анимация</b>, когда <b>танк</b> стоит.
</p>

<p>
Далее по коду идёт <b>плавный поворот башни танка в сторону курсора</b>. В этом коде есть небольшой баг: когда <b>поворот</b> идёт по часовой стрелке и <b>дуло</b> находится во II четверти окружности, при переходе курсора в I четверть <b>башня танка</b> начинает вращаться в противоположную сторону. Как работает этот код? Да очень просто.
</p>

<p>
Сначала мы получаем позицию курсора мыши и высчитываем вектор от позиции расположения <b>танка</b> до курсора.

<pre>
<code data-language="lua">
local mousePos = Input.mousePos()
local dir = self.pos - mousePos
</code>
</pre>
</p>

<p>
Затем получаем угол, до которого нам нужно <b>повернуть башню</b>.

<pre>
<code data-language="lua">
local targetAngle = -math.atan2( dir.x, dir.y ) / (math.pi / 180)
</code>
</pre>
</p>

<p>
Но наша <b>башня</b> уже повёрнута на какой-то угол, поэтому мы берём разность текущего угла, на который повёрнута <b>башня</b> и угла, до которого необходимо её повернуть. В результате получаем угол, на который необходимо "довернуть" <b>башню</b> от текущего <b>угла поворота</b>. С каждым обновлением кадра этот <b>угол</b> будет уменьшаться.

<pre>
<code data-language="lua">
local a = curAngle - targetAngle
</code>
</pre>
</p>

<p>
Далее определяем некоторую переменную <b>s</b>, на которую будет изменяться текущий <b>угол поворота башни</b>. И уже в зависимости <b>a</b> от <b>s</b> определяется, в какую сторону будет осуществляться <b>поворот</b>.

<pre>
<code data-language="lua">
local s = dt * self.max_rot_speed

if a >= -s - 0.5 and a <= s + 0.5 then
  self.top_angle = targetAngle
elseif a > s + 0.5 then
  self.top_angle = self.top_angle - s
elseif a < -s - 0.5 then
  self.top_angle = self.top_angle + s
end
</code>
</pre>
</p>

<p>
Далее определяем вектор <b>башни танка</b>. Он нам понадобится, когда будем реализовывать <b>стрельбу</b>.

<pre>
<code data-language="lua">
self.top_dir.x = math.sin( math.rad( self.top_angle ) )
self.top_dir.y = -math.cos( math.rad( self.top_angle ) )
</code>
</pre>
</p>

<p>
С <b>движениями</b> вперёд и назад и <b>поворотами</b> думаю всё понятно.
</p>

<p>
Далее осуществляется <b>стрельба</b> снарядами. Рассмотрим стрельбу на примере ракет. Для обычных снарядов принцип тотже, только у ракет ещё создаётся <b>система частиц</b>.

<pre>
<code data-language="lua">
-- Проверяем однократное нажатие правой кнопки мыши
if Input.mouseDown("r") then
  -- Создаём новый объект, это и будет наша ракета
  local ind = #self.rockets + 1
  self.rockets[ ind ] = {}

  -- Здесь определяется из какой точки будут вылетать ракеты
  -- Делаем чтобы они вылеталь из конца дула
  local x = self.pos.x - ((self.pos.y - 85) - self.pos.y) * math.sin( math.rad( self.top_angle ) )
  local y = self.pos.y + ((self.pos.y - 85) - self.pos.y) * math.cos( math.rad( self.top_angle ) )

  -- Сохраняем позицию ракеты
  self.rockets[ ind ].pos = Vector( x, y )
  
  -- Направление, в котором ракета будет двигаться
  self.rockets[ ind ].dir = Vector( self.top_dir.x, self.top_dir.y ):normalized()
  
  -- Спрайт ракеты
  self.rockets[ ind ].img = love.graphics.newImage("data/images/rocket.png")
  self.rockets[ ind ].size = Vector( self.rockets[ ind ].img:getWidth(), self.rockets[ ind ].img:getHeight() )
  
  -- Угол поворота. Равен углу поворота башни танка
  self.rockets[ ind ].angle = self.top_angle
  
  -- Указываем спрайт для системы частиц
  self.rockets[ ind ].smoke = love.graphics.newImage("data/images/rocket_smoke.png")
  
  -- Создаём систему частиц
  self.rockets[ ind ].ps = love.graphics.newParticleSystem( self.rockets[ ind ].smoke, 256 )
  self.rockets[ ind ].ps:setAreaSpread( "uniform", 0, 0 )
  self.rockets[ ind ].ps:setDirection( math.rad( self.rockets[ ind ].angle + 90 ) )
  self.rockets[ ind ].ps:setEmissionRate( 512 )
  self.rockets[ ind ].ps:setEmitterLifetime( -1 )
  self.rockets[ ind ].ps:setInsertMode("bottom")
  self.rockets[ ind ].ps:setLinearAcceleration( 0, 10, 0, 30 )
  self.rockets[ ind ].ps:setParticleLifetime( 0.1, 0.5 )
  self.rockets[ ind ].ps:setRadialAcceleration( 0, 0 )
  self.rockets[ ind ].ps:setSpeed( 30, 50 )
  self.rockets[ ind ].ps:setSpread( math.rad( 30 ) )
  self.rockets[ ind ].ps:setPosition( 
    self.rockets[ ind ].pos.x
    - ((self.rockets[ ind ].pos.y + 16)
    - self.rockets[ ind ].pos.y)
    * math.sin( math.rad( self.rockets[ ind ].angle ) ),
    self.rockets[ ind ].pos.y
    + ((self.rockets[ ind ].pos.y + 16)
    - self.rockets[ ind ].pos.y)
    * math.cos( math.rad( self.rockets[ ind ].angle ) ) )
  self.rockets[ ind ].ps:start()
end
</code>
</pre>
</p>

<p>
Для того, чтобы снаряды вылетали из конца <b>дула танка</b>, необходимо воспользоваться формулой:

<pre>
<code data-language="lua">
X = x0 + (x - x0) * cos(a) - (y - y0) * sin(a); 
Y = y0 + (y - y0) * cos(a) + (x - x0) * sin(a);
</code>
</pre>

<ul>
  <li>(x0; y0) - точка, вокруг которой вращаем</li>
  <li>(x; y) - точка, которую вращаем</li>
  <li>X, Y - новые координаты точки (x; y)</li> 
  <li>a - угол, на который повёрнута башня (в радианах)</li>
</ul>
</p>

<p>
Просто подставим наши значения и получим точку (X; Y), из которой должны вылетать <b>снаряды</b>.
</p>

<p>
<center><b>Система координат:</b></center>
<center><img src="img/tanks/tank_axes.png" width="640" height="480"></center>
</p>

<p>
С <b>системой частиц</b> пока не разбирался, все параметры были подобраны эксперементальным путём. Более подробней о системе частиц можно посмотреть <a href="http://love2d.org/wiki/ParticleSystem" target="_blank">здесь</a>.
</p>

<p>
Далее идёт обновление снарядов, проигрывается текущая <b>анимация танка</b> и обновление выхлопных газов танка.
</p>

<p>
Класс "Танк" написан, осталось добавить его в файл <b>main.lua</b>. Сохраните его в папку <b>classes</b> с названием <b>Tank.lua</b> и в файле <b>main.lua</b> после объявления всех библиотек добавьте <b>Tank = require "classes.Tank"</b>. В функции <b>love.load()</b> нужно создать экземпляр класса: <b>tank = Tank( Vector( 100, 100 ) )</b>. И вместо комментариев "Здесь будет функция обновления танка" и "Здесь будет функция отрисовки танка" нужно прописать <b>tank:update( dt )</b> и <b>tank:draw()</b>.
</p>

<p>
<center><b>Результат:</b></center>
<center><img src="img/tanks/result.png" width="640" height="480"></center>
</p>

<p>
Осталось добавить звуки, задержку между выстрелами, счётчик снарядов, вменяемый менеджер сцен, разных плюшек и можно делать свою игру.
</p>

<p>
Основной код был вырезан из одного старого проекта, так что возможно наличие ошибок.
</p>

<p>
<b>P.S.:</b> в lua новичок, так что многое в коде может показаться полным бредом, который навеяла больная фантазия автора данной статьи :)
</p>

<p>
Ну и как же обойтись без исходников: <a href="http://FileKit.org/outside/download?name=Tanks.love&uid=82&url=http://snake174.github.io/files/tanks/Tanks.love&type=file&redirect=auto" target="_blank"><b>Tanks</b></a>
</p>

<p>
<script type="text/javascript" src="//yastatic.net/share/share.js" charset="utf-8"></script><div class="yashare-auto-init" data-yashareL10n="ru" data-yashareType="none" data-yashareQuickServices="vkontakte,facebook,twitter,odnoklassniki,moimir,lj,gplus"></div>
</p>

        </td>
      </tr>
      <tr>
        <td valign="top" style="padding-top: 30px;">
          <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
          <!-- snake174.github.io banner 300x600 -->
          <ins class="adsbygoogle"
            style="display:inline-block;width:300px;height:600px"
            data-ad-client="ca-pub-4693591635005759"
            data-ad-slot="3744314425"></ins>
          <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
          </script>
        </td>
      </tr>
      <tr>
        <td colspan="2" style="height: 100px;">
          <div class="footer"></div>
          
<!-- Yandex.Metrika informer -->
<a href="https://metrika.yandex.ru/stat/?id=26840853&amp;from=informer"
target="_blank" rel="nofollow"><img src="//bs.yandex.ru/informer/26840853/3_0_FFFFFFFF_EFEFEFFF_0_pageviews"
style="width:88px; height:31px; border:0;" alt="Яндекс.Метрика" title="Яндекс.Метрика: данные за сегодня (просмотры, визиты и уникальные посетители)" onclick="try{Ya.Metrika.informer({i:this,id:26840853,lang:'ru'});return false}catch(e){}"/></a>
<!-- /Yandex.Metrika informer -->

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter26840853 = new Ya.Metrika({id:26840853,
                    webvisor:true,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true});
        } catch(e) { }
    });

    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";

    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/26840853" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
          
        </td>
      </tr>
    </table>
  </body>
</html>
